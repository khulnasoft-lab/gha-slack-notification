name: "GitHub Slack notification"
description: "GitHub action to send Slack notification when GitHub workflow start and finish"
inputs:
  type:
    description: could be message, start, finish
    required: false
    default: message
  project:
    description: name of the project (repository name is used if omitted)
    default: ""
  message:
    description: message to post on Slack
    default: ""
  extra_message:
    description: message to append to autogenerated message
    default: ""
  job_url:
    description: deprecated not used anymore
    default: ""
  SLACK_WEBHOOK_URL:
    description: Slack webhook url for all notifications
    required: true
  FAILURE_ONLY_SLACK_WEBHOOK_URL:
    description: Slack webhook url for error notification
    required: false
    default: ""
  OVERRIDE_JOB_STATUS:
    description: The hardcoded JOB status (in case of action is used in an composite action)
    required: false
    default: ""


runs:
  using: "composite"
  steps:
    - name: Fetch job check run information
      id: fetch-check-run
      uses: actions/github-script@v7
      with:
        result-encoding: string
        script: |
          const { data } = await github.rest.actions.listJobsForWorkflowRun({
            owner: context.repo.owner,
            repo: context.repo.repo,
            run_id: context.runId
          });
          const job = data.jobs.find(
            (j) => j.name.includes(context.job)
          )
          core.setOutput("job_url", job.html_url);
          core.setOutput("job_id", String(job.id));

    - name: Prepare report status
      shell: bash
      id: report-status
      env:
        NOTIF_TYPE: ${{ inputs.type }}
        SLACK_TEXT_MESSAGE: ${{ inputs.message }}
        PROJECT: ${{ inputs.project }}
        REPOSITORY: ${{ github.repository }}
        JOB_ID: ${{ steps.fetch-check-run.outputs.job_id }}
        JOB_STATUS: ${{¬†job.status }}
        REF_NAME: ${{ github.ref_name }}
        OVERRIDE_JOB_STATUS: ${{¬†inputs.OVERRIDE_JOB_STATUS }}
        EXTRA_MESSAGE: ${{ inputs.extra_message }}
      run: |
        if [ "${OVERRIDE_JOB_STATUS}" ]; then
          JOB_STATUS="${OVERRIDE_JOB_STATUS}"
        fi
        if [ "${JOB_STATUS}" == "success" ] ; then
          emoji="ü¶æ"
        elif [ "${JOB_STATUS}" == "cancelled" ] ; then
          emoji="‚úã"
        elif [ "${JOB_STATUS}" == "failure" ] ; then
          emoji="üí•"
        else
          emoji="‚ùî"
        fi

        if [ -z "$PROJECT" ]; then
          PROJECT=${REPOSITORY##*\/}
        fi

        if [ "${NOTIF_TYPE}" == "message" ]; then
          SLACK_TEXT_MESSAGE=$(cat <<EOF
        *$SLACK_TEXT_MESSAGE :${emoji}*
        Conclusion: ${JOB_STATUS}
        EOF)

        elif [ "${NOTIF_TYPE}" == "release-start" ]; then
          SLACK_TEXT_MESSAGE="*Starting release (${JOB_ID}) of $PROJECT ${REF_NAME}*"

        elif [ "${NOTIF_TYPE}" == "release-finish" ]; then
          SLACK_TEXT_MESSAGE=$(cat <<EOF
        *Release (${JOB_ID}) of $PROJECT ${REF_NAME} finished ${emoji}*
        Conclusion: ${JOB_STATUS}
        ${EXTRA_MESSAGE}
        EOF
        )

        elif [ "${NOTIF_TYPE}" == "deploy-start" ]; then
          SLACK_TEXT_MESSAGE="*Starting deployment (${JOB_ID}) of $PROJECT*"

        elif [ "${NOTIF_TYPE}" == "deploy-finish" ]; then
          if [ -d .git ]; then
            SLACK_TEXT_MESSAGE=$(cat <<EOF
        *Deployment ($JOB_ID) of $PROJECT finished ${emoji}*
        Conclusion: ${JOB_STATUS}
        \`\`\`
        $(git log -1 | sed -e 's/```/~~~/g')
        \`\`\`
        ${EXTRA_MESSAGE}
        EOF
        )
          else
            SLACK_TEXT_MESSAGE=$(cat <<EOF
        *Deployment ($JOB_ID) of $PROJECT finished ${emoji}*
        Conclusion: ${JOB_STATUS}
        ${EXTRA_MESSAGE}
        EOF
        )
          fi

        else
          echo "Unsupported notification type: ${NOTIF_TYPE}"
          exit 1
        fi

        # Escape newline/quote/... with jq
        SLACK_TEXT_MESSAGE=$(echo "$SLACK_TEXT_MESSAGE" | jq -Rsa .)
        echo "SLACK_TEXT_MESSAGE=${SLACK_TEXT_MESSAGE}" >> "$GITHUB_OUTPUT"

    - uses: slackapi/slack-github-action@v1.23.0
      with:
        # yamllint disable rule:line-length
        payload: |
          {
            "blocks": [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": ${{ steps.report-status.outputs.SLACK_TEXT_MESSAGE }}
                },
                "accessory": {
                  "type": "button",
                  "text": {
                    "type": "plain_text",
                    "text": "Job log",
                    "emoji": true
                  },
                  "url": "${{ steps.fetch-check-run.outputs.job_url }}"
                }
              }
            ]
          }
        # yamllint enable rule:line-length
      env:
        SLACK_WEBHOOK_URL: ${{ inputs.SLACK_WEBHOOK_URL }}
        SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK


    - uses: slackapi/slack-github-action@v1.23.0
      if: ${{¬†job.status == 'failure' && inputs.FAILURE_ONLY_SLACK_WEBHOOK_URL != '' }}
      with:
        # yamllint disable rule:line-length
        payload: |
          {
            "blocks": [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": ${{ steps.report-status.outputs.SLACK_TEXT_MESSAGE }}
                },
                "accessory": {
                  "type": "button",
                  "text": {
                    "type": "plain_text",
                    "text": "Job log",
                    "emoji": true
                  },
                  "url": "${{ steps.fetch-check-run.outputs.job_url }}"
                }
              }
            ]
          }
        # yamllint enable rule:line-length
      env:
        SLACK_WEBHOOK_URL: ${{ inputs.FAILURE_ONLY_SLACK_WEBHOOK_URL }}
        SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK
